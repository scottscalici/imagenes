<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Generador de JSON ‚Äì Verbos (Conjugatr√≥n)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-slate-50 text-slate-900 min-h-screen">
  <main class="max-w-6xl mx-auto px-4 py-8 space-y-8">
    <!-- Header -->
    <header class="bg-indigo-600 text-white rounded-2xl shadow-lg p-6 flex flex-col gap-2 md:flex-row md:items-center md:justify-between">
      <div>
        <h1 class="text-2xl md:text-3xl font-bold">
          Generador de JSON v2 ‚Äì Verbos (Conjugatr√≥n)
        </h1>
        <p class="text-sm md:text-base text-indigo-100">
          Crea sublistas de <strong>conjugaciones</strong> a partir de tus bancos grandes (presente, pret√©rito, etc.).
        </p>
      </div>
      <div class="text-xs md:text-sm text-indigo-100">
        <p>üß© Paso 1: Escoge bancos de verbos (tiempos)</p>
        <p>üéØ Paso 2: Filtra por tags y configura sets</p>
      </div>
    </header>

    <!-- Sources section -->
    <section class="bg-white rounded-2xl shadow p-6 space-y-4 border border-slate-200">
      <h2 class="text-xl font-semibold">Paso 1: Seleccionar bancos de verbos</h2>
      <p class="text-sm text-slate-600">
        Marca los bancos (tiempos) que quieras incluir. Opcionalmente, indica cu√°ntas
        <strong>conjugaciones</strong> por set debe aportar cada banco. Si dejas el campo vac√≠o,
        se reparte autom√°ticamente.
      </p>

      <div id="sourcesList" class="grid md:grid-cols-2 gap-4">
        <!-- JS will populate this with VERB_SOURCES -->
      </div>
    </section>

    <!-- Tag filter + config section -->
    <section class="bg-white rounded-2xl shadow p-6 space-y-6 border border-slate-200">
      <h2 class="text-xl font-semibold">Paso 2: Filtrar por tags y configurar sets</h2>

      <!-- Tag filter -->
      <div class="space-y-2">
        <label class="block text-sm font-medium text-slate-700">
          Filtrar por tags (<code>tipo_ver–±–æ</code>)
        </label>
        <textarea
          id="tagFilterInput"
          class="w-full rounded-xl border-slate-300 shadow-sm focus:ring-indigo-500 focus:border-indigo-500 text-xs px-3 py-2 font-mono h-16"
          placeholder="Ej.: pret_gar, cambio_ortogr√°fico, los_4_irregulares, uir&#10;Deja vac√≠o para usar todos los verbos."
        ></textarea>
        <p class="text-xs text-slate-500">
          Solo se usar√°n las entradas cuyo array <code>tipo_ver–±–æ</code> contenga al menos uno de los tags indicados.
          Puedes separarlos por comas, espacios o saltos de l√≠nea.
        </p>
      </div>

      <!-- Numeric config -->
      <div class="grid md:grid-cols-2 gap-4">
        <div class="space-y-1">
          <label class="block text-sm font-medium text-slate-700">
            Conjugaciones por set
          </label>
          <input
            id="formsPerSetInput"
            type="number"
            value="20"
            min="1"
            class="w-full rounded-xl border-slate-300 shadow-sm focus:ring-indigo-500 focus:border-indigo-500 text-sm px-3 py-2"
          />
          <p class="text-xs text-slate-500">
            Ej.: 20 entradas individuales (como <code>llamar</code> ‚Äì <code>yo</code>, no todo el paradigma).
          </p>
        </div>

        <div class="space-y-1">
          <label class="block text-sm font-medium text-slate-700">
            N√∫mero de sets a generar
          </label>
          <input
            id="numSetsInput"
            type="number"
            value="3"
            min="1"
            class="w-full rounded-xl border-slate-300 shadow-sm focus:ring-indigo-500 focus:border-indigo-500 text-sm px-3 py-2"
          />
          <p class="text-xs text-slate-500">
            Por ejemplo, 5 si quieres <code>PRES-1</code> hasta <code>PRES-5</code>.
          </p>
        </div>

        <div class="space-y-1">
          <label class="block text-sm font-medium text-slate-700">
            Etiqueta base del set
          </label>
          <input
            id="baseLabelInput"
            type="text"
            value="presente"
            class="w-full rounded-xl border-slate-300 shadow-sm focus:ring-indigo-500 focus:border-indigo-500 text-sm px-3 py-2"
          />
          <p class="text-xs text-slate-500">
            Se usar√° como prefijo: <code>BASE-1</code>, <code>BASE-2</code>, etc.
          </p>
        </div>

        <div class="space-y-1">
          <label class="block text-sm font-medium text-slate-700">
            √çndice inicial
          </label>
          <input
            id="startIndexInput"
            type="number"
            value="1"
            min="0"
            class="w-full rounded-xl border-slate-300 shadow-sm focus:ring-indigo-500 focus:border-indigo-500 text-sm px-3 py-2"
          />
          <p class="text-xs text-slate-500">
            √ötil si ya existen presente-1, presente-2‚Ä¶ y quieres continuar en presente-6, etc.
          </p>
        </div>
      </div>

      <div class="border-t border-slate-200 pt-4 flex flex-col gap-3 md:flex-row md:items-center md:justify-between">
        <p class="text-sm text-slate-600">
          El generador reparte <strong>conjugaciones</strong> de forma uniforme entre los bancos seleccionados
          si no indicas cuotas espec√≠ficas.
        </p>
        <button
          id="generateBtn"
          type="button"
          class="inline-flex items-center gap-2 px-4 py-2 rounded-xl text-sm font-semibold bg-emerald-600 text-white hover:bg-emerald-700 focus:outline-none focus:ring-2 focus:ring-emerald-400"
        >
          üöÄ Generar sets
        </button>
      </div>

      <p id="statusMessage" class="text-sm mt-2 text-slate-600"></p>
    </section>

    <!-- Results -->
    <section class="bg-white rounded-2xl shadow p-6 space-y-4 border border-slate-200">
      <h2 class="text-xl font-semibold">Resultados ‚Äì Sets generados</h2>
      <p class="text-sm text-slate-600">
        Cada bloque corresponde a un JSON independiente (solo el array de entradas de verbo).
        Puedes copiarlo o descargarlo como archivo <code>.json</code>.
      </p>

      <div id="resultsContainer" class="space-y-6">
        <!-- Generated sets go here -->
      </div>
    </section>
  </main>

  <script>
    // --------------------------------------------------------------------
    // 1. Fuentes de verbos en GitHub (usamos URLs "blob" pero las convertimos a "raw")
    // --------------------------------------------------------------------
    const VERB_SOURCES = [
      {
        id: "presente",
        label: "Verbos ‚Äì Presente",
        url: "https://github.com/scottscalici/imagenes/blob/main/verbos/presente.json"
      },
      {
        id: "preterito",
        label: "Verbos ‚Äì Pret√©rito",
        url: "https://github.com/scottscalici/imagenes/blob/main/verbos/preterito.json"
      }
      // M√°s tiempos a futuro:
      // { id: "imperfecto", label: "Verbos ‚Äì Imperfecto", url: "https://github.com/.../imperfecto.json" }
    ];

    function toRawGithubUrl(url) {
      if (url.includes("github.com") && url.includes("/blob/")) {
        return url
          .replace("github.com", "raw.githubusercontent.com")
          .replace("/blob/", "/");
      }
      return url;
    }

    // --------------------------------------------------------------------
    // 2. Helpers
    // --------------------------------------------------------------------
    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    function downloadJSON(filename, data) {
      const blob = new Blob([data], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    // Carga un banco de verbos tal cual (lista plana de entradas)
    async function loadVerbSource(source) {
      const rawUrl = toRawGithubUrl(source.url);
      const res = await fetch(rawUrl);
      if (!res.ok) {
        throw new Error("Error al cargar " + source.label);
      }

      const raw = await res.json();

      let items;
      if (Array.isArray(raw)) {
        items = raw;
      } else {
        const topKey = Object.keys(raw)[0];
        items = raw[topKey];
      }

      if (!Array.isArray(items)) {
        throw new Error("Formato inesperado en " + source.label);
      }

      return items;
    }

    // --------------------------------------------------------------------
    // 3. UI wiring
    // --------------------------------------------------------------------
    const sourcesList = document.getElementById("sourcesList");
    const generateBtn = document.getElementById("generateBtn");
    const resultsContainer = document.getElementById("resultsContainer");
    const statusMessage = document.getElementById("statusMessage");
    const formsPerSetInput = document.getElementById("formsPerSetInput");
    const numSetsInput = document.getElementById("numSetsInput");
    const baseLabelInput = document.getElementById("baseLabelInput");
    const startIndexInput = document.getElementById("startIndexInput");
    const tagFilterInput = document.getElementById("tagFilterInput");

    function renderSources() {
      sourcesList.innerHTML = "";
      VERB_SOURCES.forEach(src => {
        const card = document.createElement("div");
        card.className =
          "border border-slate-200 rounded-xl p-3 bg-slate-50 space-y-2";

        card.innerHTML = `
          <label class="flex items-start gap-2">
            <input type="checkbox" class="src-enabled mt-1 rounded border-slate-300 text-indigo-600" data-id="${src.id}" />
            <div>
              <div class="text-sm font-medium text-slate-800">${src.label}</div>
              <div class="text-xs text-slate-500 break-all">${src.url}</div>
            </div>
          </label>
          <div class="space-y-1">
            <label class="block text-xs font-medium text-slate-700">
              Conjugaciones por set de este banco (opcional)
            </label>
            <input
              type="number"
              min="0"
              class="src-quota w-full rounded-xl border-slate-300 shadow-sm focus:ring-indigo-500 focus:border-indigo-500 text-xs px-3 py-1.5"
              placeholder="Ej. 10 (si lo dejas vac√≠o se reparte autom√°ticamente)"
              data-id="${src.id}"
            />
          </div>
        `;

        sourcesList.appendChild(card);
      });
    }

    renderSources();

    // --------------------------------------------------------------------
    // 4. Generar sets (unidad = ENTRADA/CONJUGACI√ìN)
    // --------------------------------------------------------------------
    generateBtn.addEventListener("click", async () => {
      statusMessage.textContent = "";
      statusMessage.className = "text-sm mt-2 text-slate-600";
      resultsContainer.innerHTML = "";

      const totalFormsPerSet = parseInt(formsPerSetInput.value, 10) || 20;
      const numSets = parseInt(numSetsInput.value, 10) || 1;
      const baseLabel = baseLabelInput.value.trim() || "SET";
      const startIndex = parseInt(startIndexInput.value, 10) || 1;

      // Tag filter
      const rawTagFilter = tagFilterInput.value.trim();
      let activeTags = [];
      if (rawTagFilter) {
        activeTags = rawTagFilter
          .split(/[,\s]+/)
          .map(t => t.trim())
          .filter(Boolean);
      }

      // Selected sources
      const enabledCheckboxes = Array.from(
        document.querySelectorAll(".src-enabled")
      ).filter(cb => cb.checked);

      if (!enabledCheckboxes.length) {
        statusMessage.textContent =
          "‚ùå No has seleccionado ning√∫n banco de verbos. Marca al menos uno.";
        statusMessage.className = "text-sm mt-2 text-red-600";
        return;
      }

      const selectedSources = enabledCheckboxes.map(cb => {
        const id = cb.getAttribute("data-id");
        const src = VERB_SOURCES.find(s => s.id === id);
        const quotaInput = document.querySelector(
          `.src-quota[data-id="${id}"]`
        );
        const quota = quotaInput.value
          ? Math.max(0, parseInt(quotaInput.value, 10) || 0)
          : null;
        return { ...src, quotaPerSet: quota };
      });

      // Load verb entries
      statusMessage.textContent =
        "‚è≥ Cargando conjugaciones de los bancos seleccionados‚Ä¶";

      let logicalSources;
      try {
        const loadedArrays = await Promise.all(
          selectedSources.map(src => loadVerbSource(src))
        );

        logicalSources = selectedSources.map((src, idx) => {
          let items = loadedArrays[idx];

          // Apply tag filter if any
          if (activeTags.length > 0) {
            items = items.filter(entry => {
              const tags = Array.isArray(entry["tipo_ver–±–æ"])
                ? entry["tipo_ver–±–æ"]
                : [];
              return tags.some(tag => activeTags.includes(tag));
            });
          }

          return {
            label: src.label,
            items,
            quotaPerSet: src.quotaPerSet
          };
        });
      } catch (e) {
        console.error(e);
        statusMessage.textContent =
          "‚ùå Error al cargar uno o m√°s bancos de verbos. Revisa la consola del navegador para m√°s detalles.";
        statusMessage.className = "text-sm mt-2 text-red-600";
        return;
      }

      // Check availability
      const totalItemsAvailable = logicalSources
        .map(s => s.items.length)
        .reduce((a, b) => a + b, 0);

      if (!totalItemsAvailable) {
        statusMessage.textContent =
          "‚ùå No hay conjugaciones disponibles con los filtros actuales (revisa los tags o las fuentes seleccionadas).";
        statusMessage.className = "text-sm mt-2 text-red-600";
        return;
      }

      // Quotas (conjugaciones por set y por banco)
      const fixedTotal = logicalSources
        .map(s => s.quotaPerSet || 0)
        .reduce((a, b) => a + b, 0);

      if (fixedTotal > totalFormsPerSet) {
        statusMessage.textContent =
          "‚ùå La suma de las cuotas fijas por banco es mayor que las conjugaciones totales por set.";
        statusMessage.className = "text-sm mt-2 text-red-600";
        return;
      }

      const remaining = totalFormsPerSet - fixedTotal;
      const autoSources = logicalSources.filter(s => s.quotaPerSet === null);

      if (autoSources.length === 0 && remaining > 0) {
        statusMessage.textContent =
          "‚ö†Ô∏è Algunas conjugaciones por set quedar√°n sin asignar porque todos los bancos tienen cuota fija.";
        statusMessage.className = "text-sm mt-2 text-amber-600";
      }

      if (autoSources.length > 0 && remaining > 0) {
        const baseAuto = Math.floor(remaining / autoSources.length);
        let leftover = remaining % autoSources.length;
        for (const s of autoSources) {
          s.quotaPerSet = baseAuto + (leftover > 0 ? 1 : 0);
          leftover--;
        }
      } else {
        for (const s of autoSources) {
          s.quotaPerSet = 0;
        }
      }

      const finalTotalForms = logicalSources
        .map(s => s.quotaPerSet || 0)
        .reduce((a, b) => a + b, 0);

      if (finalTotalForms !== totalFormsPerSet) {
        statusMessage.textContent =
          "‚ö†Ô∏è Aviso: el total asignado por set (" +
          finalTotalForms +
          " conjugaciones) no coincide exactamente con el solicitado (" +
          totalFormsPerSet +
          "). Se usar√°n " +
          finalTotalForms +
          " conjugaciones por set.";
        statusMessage.className = "text-sm mt-2 text-amber-600";
      } else {
        statusMessage.textContent =
          "‚úÖ Cuotas por banco calculadas. Generando sets‚Ä¶";
        statusMessage.className = "text-sm mt-2 text-emerald-700";
      }

      // Build pools per source (cada entrada = 1 conjugaci√≥n)
      const sourcePools = logicalSources.map((s, sIndex) => {
        const entries = s.items.map((item, idx) => ({
          sourceIndex: sIndex,
          itemIndex: idx,
          item
        }));
        return shuffle(entries);
      });

      let lastSetKeys = new Set();
      const allResults = [];

      for (let setIdx = 0; setIdx < numSets; setIdx++) {
        const setItems = [];
        const usedKeysThisSet = new Set();

        logicalSources.forEach((s, sIndex) => {
          const quota = s.quotaPerSet || 0;
          if (quota <= 0) return;

          let pool = sourcePools[sIndex];
          if (!pool.length) return;

          let picksNeeded = quota;

          // Preferir entradas que NO se usaron en el set anterior
          let candidates = pool.filter(entry => {
            const key = sIndex + "|" + entry.itemIndex;
            return !lastSetKeys.has(key);
          });

          if (candidates.length < picksNeeded) {
            candidates = pool.slice();
          }

          shuffle(candidates);

          const chosen = [];
          for (let i = 0; i < candidates.length && picksNeeded > 0; i++) {
            const entry = candidates[i];
            const key = sIndex + "|" + entry.itemIndex;
            if (usedKeysThisSet.has(key)) continue;
            chosen.push(entry);
            usedKeysThisSet.add(key);
            picksNeeded--;
          }

          const chosenKeys = new Set(
            chosen.map(e => sIndex + "|" + e.itemIndex)
          );
          pool = pool.filter(
            e => !chosenKeys.has(sIndex + "|" + e.itemIndex)
          );
          sourcePools[sIndex] = pool;

          chosen.forEach(entry => setItems.push(entry.item));
        });

        if (!setItems.length) {
          statusMessage.textContent =
            "‚ö†Ô∏è Sin suficientes conjugaciones para generar m√°s sets. Se generaron " +
            setIdx +
            " sets antes de agotar los bancos.";
          statusMessage.className = "text-sm mt-2 text-amber-600";
          break;
        }

        shuffle(setItems);

        const labelIndex = startIndex + setIdx;
        const setLabel = baseLabel + "-" + labelIndex;

        allResults.push({
          label: setLabel,
          items: setItems
        });
        lastSetKeys = usedKeysThisSet;
      }

      if (!allResults.length) return;

      resultsContainer.innerHTML = "";
      allResults.forEach(set => {
        const wrapper = document.createElement("div");
        wrapper.className =
          "border border-slate-200 rounded-xl p-4 bg-slate-50 space-y-2";

        const header = document.createElement("div");
        header.className =
          "flex flex-col md:flex-row md:items-center md:justify-between gap-2";

        const title = document.createElement("div");
        title.innerHTML = `
          <h3 class="text-sm font-semibold text-slate-800">
            Set: <span class="font-mono">${set.label}</span>
          </h3>
          <p class="text-xs text-slate-500">
            Conjugaciones: ${set.items.length}
          </p>
        `;

        const btn = document.createElement("button");
        btn.type = "button";
        btn.className =
          "inline-flex items-center gap-1 px-3 py-1.5 rounded-xl text-xs font-medium bg-emerald-600 text-white hover:bg-emerald-700 focus:outline-none focus:ring-2 focus:ring-emerald-400";
        btn.textContent = "‚¨áÔ∏è Descargar JSON";
        btn.addEventListener("click", () => {
          const data = JSON.stringify(set.items, null, 2);
          downloadJSON(set.label + ".json", data);
        });

        header.appendChild(title);
        header.appendChild(btn);

        const textarea = document.createElement("textarea");
        textarea.className =
          "w-full h-40 rounded-xl border-slate-300 shadow-sm focus:ring-indigo-500 focus:border-indigo-500 text-xs px-3 py-2 font-mono";
        textarea.readOnly = true;
        textarea.value = JSON.stringify(set.items, null, 2);

        wrapper.appendChild(header);
        wrapper.appendChild(textarea);
        resultsContainer.appendChild(wrapper);
      });

      statusMessage.textContent +=
        "  ‚úÖ Sets generados: " + allResults.length + ".";
    });
  </script>
</body>
</html>
