<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Constructor de JSON ‚Äì Verbos</title>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-slate-100 min-h-screen">
  <header class="bg-white shadow-sm">
    <div class="max-w-6xl mx-auto px-4 py-3 flex flex-col gap-2 sm:flex-row sm:items-center sm:justify-between">
      <div>
        <h1 class="text-lg sm:text-xl font-bold text-slate-800">
          Constructor de conjuntos ‚Äì Verbos (bancos)
        </h1>
        <p class="text-xs sm:text-sm text-slate-500">
          Carga <code>banco_presente.json</code> o <code>banco_preterito.json</code>, filtra por tags y
          selecciona hasta 20 conjugaciones (no todo el paradigma).
        </p>
      </div>
      <div class="flex flex-col items-end gap-1 text-right">
        <p id="status" class="text-xs text-slate-500">Cargando datos‚Ä¶</p>
        <p id="countInfo" class="text-xs text-slate-700 font-semibold">0 seleccionados (m√°x. 20)</p>
      </div>
    </div>
  </header>

  <main class="max-w-6xl mx-auto px-4 py-6 space-y-6">
    <!-- Source / bank selection -->
    <section class="bg-white rounded-2xl shadow p-4 space-y-3">
      <div class="flex flex-col gap-3 md:flex-row md:items-end md:justify-between">
        <div class="space-y-2">
         <label class="block text-xs font-semibold text-slate-600 uppercase tracking-wide">
  Banco de verbos
</label>
<select id="bankSelect"
        class="border rounded-lg px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-sky-400">
  <!-- JS llenar√° las opciones -->
</select>
<p class="text-[11px] text-slate-500">
  Cambia de banco para construir conjuntos distintos. Puedes mezclar tiempos m√°s adelante si quieres.
</p>

        </div>

        <div class="flex-1 space-y-2">
          <label class="block text-xs font-semibold text-slate-600 uppercase tracking-wide">
            Buscar (infinitivo, sujeto o contexto)
          </label>
          <input id="searchInput"
                 type="text"
                 class="w-full border rounded-lg px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-sky-400"
                 placeholder="ej. hablar, yo, supermercado, quedarse‚Ä¶" />
        </div>

        <div class="flex flex-wrap gap-2 items-center">
          <button id="btnClear"
                  class="px-3 py-2 rounded-lg bg-slate-100 text-slate-700 text-xs font-semibold">
            Limpiar selecci√≥n
          </button>
          <button id="btnGenerate"
                  class="px-4 py-2 rounded-lg bg-emerald-600 text-white text-xs sm:text-sm font-semibold disabled:opacity-40 disabled:cursor-not-allowed"
                  disabled>
            Generar JSON (m√°x. 20)
          </button>
        </div>
      </div>

      <!-- Tag Filters -->
      <div class="border-t pt-3 mt-3">
        <label class="block text-xs font-semibold text-slate-600 uppercase tracking-wide mb-2">
          Filtrar por etiquetas (tags)
        </label>

        <div id="tagFilters" class="flex flex-wrap gap-2 text-xs">
          <!-- JS will dynamically populate all available tags -->
        </div>

        <p class="text-[11px] text-slate-500 mt-1">
          Los tags se leen tanto de <code>tags</code> como de <code>tipo_verbo</code> / <code>tipo_ver–±–æ</code>.
          Solo se muestran las conjugaciones cuyos tags (del verbo) incluyan todos los seleccionados.
        </p>
      </div>
    </section>

    <!-- List + Output -->
    <div class="grid gap-6 lg:grid-cols-[1.4fr,1fr]">
      <!-- List of items -->
      <section class="bg-white rounded-2xl shadow p-4 flex flex-col min-h-[300px]">
        <div class="flex items-center justify-between mb-3">
          <h2 class="text-sm font-semibold text-slate-700">
            √çtems disponibles
          </h2>
          <p id="listInfo" class="text-xs text-slate-500"></p>
        </div>

        <div id="itemsContainer"
             class="flex-1 min-h-[200px] max-h-[520px] overflow-auto space-y-2 text-sm">
          <!-- dynamically filled -->
        </div>
      </section>

      <!-- Output JSON -->
      <section class="bg-white rounded-2xl shadow p-4 space-y-3">
        <div class="flex items-center justify-between">
          <h2 class="text-sm font-semibold text-slate-700">
            Resultado JSON (para guardar como presente1.json, preterito1.json, etc.)
          </h2>
          <button id="btnCopy"
                  class="px-3 py-1.5 rounded-lg bg-sky-600 text-white text-xs font-semibold disabled:opacity-40 disabled:cursor-not-allowed"
                  disabled>
            Copiar al portapapeles
          </button>
        </div>

        <textarea id="outputJson"
                  class="w-full h-72 border rounded-lg px-3 py-2 text-xs font-mono bg-slate-50 focus:outline-none focus:ring-2 focus:ring-sky-400"
                  placeholder="Selecciona hasta 20 √≠tems y haz clic en ‚ÄúGenerar JSON‚Äù."
                  readonly></textarea>

        <p class="text-xs text-slate-500">
          Paso siguiente: crea un archivo como <code>presente1.json</code> (o similar) en tu repositorio
          y pega este contenido. Luego tu m√≥dulo de pr√°ctica solo necesita la URL de ese archivo.
        </p>
      </section>
    </div>
  </main>

<script>
  // üîπ Todos los bancos de verbos que vas a usar
  const VERB_BANKS = {
    presente: {
      label: "Presente",
      url: "https://raw.githubusercontent.com/scottscalici/imagenes/main/verbos/banco_presente.json",
    },
    preterito: {
      label: "Pret√©rito",
      url: "https://raw.githubusercontent.com/scottscalici/imagenes/main/verbos/banco_preterito.json",
    },
    imperfecto: {
      label: "Imperfecto",
      url: "https://raw.githubusercontent.com/scottscalici/imagenes/main/verbos/banco_imperfecto.json",
    },
    presentedesubjuntivo: {
      label: "Presente de subjuntivo",
      url: "https://raw.githubusercontent.com/scottscalici/imagenes/main/verbos/banco_presentedesubjuntivo.json",
    },
    futuro: {
      label: "Futuro",
      url: "https://raw.githubusercontent.com/scottscalici/imagenes/main/verbos/banco_futuro.json",
    },
    condicional: {
      label: "Condicional",
      url: "https://raw.githubusercontent.com/scottscalici/imagenes/main/verbos/banco_condicional.json",
    },
    participiospasados: {
      label: "Participios pasados",
      url: "https://raw.githubusercontent.com/scottscalici/imagenes/main/verbos/banco_participiospasados.json",
    },
    presenteprogresivo: {
      label: "Presente progresivo",
      url: "https://raw.githubusercontent.com/scottscalici/imagenes/main/verbos/banco_presenteprogresivo.json",
    },
    preteritoperfecto: {
      label: "Pret√©rito perfecto",
      url: "https://raw.githubusercontent.com/scottscalici/imagenes/main/verbos/banco_preteritoperfecto.json",
    },
    preteritoperfectodesubjuntivo: {
      label: "Pret√©rito perfecto de subjuntivo",
      url: "https://raw.githubusercontent.com/scottscalici/imagenes/main/verbos/banco_preteritoperfectodesubjuntivo.json",
    },
    pluscuamperfecto: {
      label: "Pluscuamperfecto",
      url: "https://raw.githubusercontent.com/scottscalici/imagenes/main/verbos/banco_pluscuamperfecto.json",
    },
    pluscuamperfectodesubjuntivo: {
      label: "Pluscuamperfecto de subjuntivo",
      url: "https://raw.githubusercontent.com/scottscalici/imagenes/main/verbos/banco_pluscuamperfectodesubjuntivo.json",
    },
    futuroperfecto: {
      label: "Futuro perfecto",
      url: "https://raw.githubusercontent.com/scottscalici/imagenes/main/verbos/banco_futuroperfecto.json",
    },
    condicionalperfecto: {
      label: "Condicional perfecto",
      url: "https://raw.githubusercontent.com/scottscalici/imagenes/main/verbos/banco_condicionalperfecto.json",
    },
    imperfectodesubjuntivo: {
      label: "Imperfecto de subjuntivo",
      url: "https://raw.githubusercontent.com/scottscalici/imagenes/main/verbos/banco_imperfectodesubjuntivo.json",
    },
    mandatosfamiliares: {
      label: "Mandatos familiares",
      url: "https://raw.githubusercontent.com/scottscalici/imagenes/main/verbos/banco_mandatos_informales.json",
    },
    mandatosformales: {
      label: "Mandatos formales",
      url: "https://raw.githubusercontent.com/scottscalici/imagenes/main/verbos/banco_mandatosformales.json",
    },
    mandatosplurales: {
      label: "Mandatos plurales",
      url: "https://raw.githubusercontent.com/scottscalici/imagenes/main/verbos/banco_mandatosplurales.json",
    },
    mandatosnosotros: {
      label: "Mandatos nosotros",
      url: "https://raw.githubusercontent.com/scottscalici/imagenes/main/verbos/banco_mandatosnosotros.json",
    },
    mandatosvosotros: {
      label: "Mandatos vosotros",
      url: "https://raw.githubusercontent.com/scottscalici/imagenes/main/verbos/banco_mandatosvosotros.json",
    },
  };

  let currentBank = "presente";

  let masterItems = [];
  let filteredItems = [];
  const selectedIndices = new Set(); // indices relative to masterItems
  let allTags = new Set();
  let activeTags = new Set();

  const statusEl = document.getElementById("status");
  const countInfoEl = document.getElementById("countInfo");
  const listInfoEl = document.getElementById("listInfo");
  const itemsContainer = document.getElementById("itemsContainer");
  const searchInput = document.getElementById("searchInput");
  const bankSelect = document.getElementById("bankSelect");
  const btnGenerate = document.getElementById("btnGenerate");
  const btnClear = document.getElementById("btnClear");
  const btnCopy = document.getElementById("btnCopy");
  const outputJson = document.getElementById("outputJson");

  function updateCountInfo() {
    const count = selectedIndices.size;
    countInfoEl.textContent = `${count} seleccionados (m√°x. 20)`;
    btnGenerate.disabled = (count === 0 || count > 20);
    btnCopy.disabled = !outputJson.value.trim();
  }

  // üîπ Tags desde distintas claves
  function getRawTagsFromEntry(v) {
    if (!v) return [];
    if (Array.isArray(v.tags)) return v.tags;
    if (Array.isArray(v["tipo_verbo"])) return v["tipo_verbo"];
    if (Array.isArray(v["tipo_ver–±–æ"])) return v["tipo_ver–±–æ"]; // por si acaso con la "o" rara
    return [];
  }

  function extractTagsFromYoEntries(items) {
    allTags = new Set();
    items.forEach(v => {
      if (v.sujeto?.trim().toLowerCase() === "yo") {
        const entryTags = getRawTagsFromEntry(v);
        entryTags.forEach(t => allTags.add(t));
      }
    });
  }

  function renderTagFilters() {
    const container = document.getElementById("tagFilters");
    container.innerHTML = "";
    activeTags = new Set(); // reset al cambiar de banco

    if (!allTags.size) {
      container.innerHTML =
        '<span class="text-[11px] text-slate-400">Este banco no tiene tags detectables.</span>';
      return;
    }

    Array.from(allTags).sort().forEach(tag => {
      const id = `tag-${tag}`;
      const wrapper = document.createElement("label");
      wrapper.className =
        "flex items-center gap-1 bg-slate-100 px-2 py-1 rounded cursor-pointer";

      wrapper.innerHTML = `
        <input type="checkbox" id="${id}" data-tag="${tag}" class="h-3 w-3">
        <span>${tag}</span>
      `;

      container.appendChild(wrapper);
    });

    container.querySelectorAll("input[type='checkbox']").forEach(cb => {
      cb.addEventListener("change", () => {
        const tag = cb.dataset.tag;
        if (cb.checked) activeTags.add(tag);
        else activeTags.delete(tag);
        applyFilter();
      });
    });
  }

  function renderList() {
    itemsContainer.innerHTML = "";

    if (!filteredItems.length) {
      itemsContainer.innerHTML =
        '<p class="text-xs text-slate-500">No hay √≠tems que coincidan con la b√∫squeda/filtros.</p>';
      listInfoEl.textContent = "";
      return;
    }

    filteredItems.forEach(({ item, indexInMaster }) => {
      const isSelected = selectedIndices.has(indexInMaster);

      const row = document.createElement("label");
      row.className =
        "flex items-start gap-2 border rounded-lg px-3 py-2 cursor-pointer hover:bg-slate-50 text-xs sm:text-sm";

      row.innerHTML = `
        <input type="checkbox"
               class="mt-1 h-4 w-4 text-sky-600 border-slate-300 rounded"
               data-master-index="${indexInMaster}"
               ${isSelected ? "checked" : ""} />
        <div class="flex-1">
          <div class="flex flex-wrap items-center gap-1">
            <span class="font-semibold text-slate-800">${item.sujeto}</span>
            <span class="text-slate-800">${item.contexto || ""}</span>
          </div>
          <div class="text-[11px] text-slate-500 mt-0.5">
            ${item.infinitivo} ¬∑ forma correcta: <code>${item.forma}</code>
            ¬∑ traducci√≥n: ${item.traducci√≥n || ""} ¬∑ tiempo: ${item.tiempo || ""}
          </div>
        </div>
      `;

      itemsContainer.appendChild(row);
    });

    listInfoEl.textContent = `${filteredItems.length} √≠tems visibles`;
    updateCountInfo();

    itemsContainer.querySelectorAll('input[type="checkbox"]').forEach(cb => {
      cb.addEventListener("change", () => {
        const idx = Number(cb.dataset.masterIndex);
        if (cb.checked) {
          if (selectedIndices.size >= 20) {
            cb.checked = false;
            return;
          }
          selectedIndices.add(idx);
        } else {
          selectedIndices.delete(idx);
        }
        updateCountInfo();
      });
    });
  }

  function applyFilter() {
    const q = searchInput.value.trim().toLowerCase();

    filteredItems = masterItems
      .map((item, indexInMaster) => ({ item, indexInMaster }))
      .filter(({ item }) => {
        const haystack = (
          (item.infinitivo || "") + " " +
          (item.sujeto || "") + " " +
          (item.contexto || "")
        ).toLowerCase();

        const passText = !q || haystack.includes(q);

        let passTags = true;
        if (activeTags.size) {
          const subjLower = (item.sujeto || "").trim().toLowerCase();
          let tags = [];

          if (subjLower === "yo") {
            tags = getRawTagsFromEntry(item);
          } else {
            const yo = masterItems.find(
              x =>
                x.infinitivo === item.infinitivo &&
                (x.tiempo === item.tiempo || !x.tiempo || !item.tiempo) &&
                (x.sujeto || "").trim().toLowerCase() === "yo"
            );
            tags = getRawTagsFromEntry(yo);
          }

          if (!tags.length) {
            passTags = false;
          } else {
            passTags = Array.from(activeTags).every(t => tags.includes(t));
          }
        }

        return passText && passTags;
      });

    renderList();
  }

  async function loadMasterJson() {
    try {
      const bank = VERB_BANKS[currentBank];
      const url = bank.url;

      const res = await fetch(url);
      if (!res.ok) {
        throw new Error(`HTTP ${res.status}`);
      }

      let data = await res.json();

      // 1) Objeto con arrays dentro
      if (!Array.isArray(data) && typeof data === "object" && data !== null) {
        const arrays = Object.values(data).filter(Array.isArray);
        if (arrays.length) {
          data = arrays.flat();
        }
      }

      // 2) Array de arrays ‚Üí aplanar recursivamente
      if (Array.isArray(data)) {
        const flatten = (arr) =>
          arr.reduce(
            (acc, el) =>
              Array.isArray(el) ? acc.concat(flatten(el)) : acc.concat(el),
            []
          );
        data = flatten(data);
      } else {
        data = [];
      }

      masterItems = data;

      extractTagsFromYoEntries(masterItems);
      renderTagFilters();

      selectedIndices.clear();
      outputJson.value = "";
      btnCopy.disabled = true;
      updateCountInfo();

      statusEl.textContent =
        `Cargados ${masterItems.length} √≠tems del banco ${bank.label}.`;
      applyFilter();
    } catch (err) {
      console.error(err);
      masterItems = [];
      filteredItems = [];
      selectedIndices.clear();
      extractTagsFromYoEntries(masterItems);
      renderTagFilters();
      renderList();
      outputJson.value = "";
      btnCopy.disabled = true;
      updateCountInfo();

      statusEl.textContent =
        "No se pudo cargar este banco (a√∫n no creado o error de red).";
    }
  }

  // Generar JSON para los seleccionados
  btnGenerate.addEventListener("click", () => {
    if (!selectedIndices.size || selectedIndices.size > 20) return;

    const indicesSorted = Array.from(selectedIndices).sort((a, b) => a - b);
    const selectedItems = indicesSorted.map(i => masterItems[i]);

    const jsonString = JSON.stringify(selectedItems, null, 2);
    outputJson.value = jsonString;
    btnCopy.disabled = false;
  });

  // Limpiar selecci√≥n
  btnClear.addEventListener("click", () => {
    selectedIndices.clear();
    updateCountInfo();
    renderList();
    outputJson.value = "";
    btnCopy.disabled = true;
  });

  // Filtrar al escribir
  searchInput.addEventListener("input", () => {
    applyFilter();
  });

  // Copiar al portapapeles
  btnCopy.addEventListener("click", async () => {
    const text = outputJson.value;
    if (!text.trim()) return;
    try {
      await navigator.clipboard.writeText(text);
      btnCopy.textContent = "¬°Copiado!";
      setTimeout(() => (btnCopy.textContent = "Copiar al portapapeles"), 1500);
    } catch {
      btnCopy.textContent = "Error al copiar";
      setTimeout(() => (btnCopy.textContent = "Copiar al portapapeles"), 1500);
    }
  });

  // üîπ Poblar el <select> con todos los bancos
  function populateBankSelect() {
    bankSelect.innerHTML = "";
    Object.entries(VERB_BANKS).forEach(([key, cfg]) => {
      const opt = document.createElement("option");
      opt.value = key;
      opt.textContent = cfg.label;
      bankSelect.appendChild(opt);
    });
    bankSelect.value = currentBank;
  }

  bankSelect.addEventListener("change", () => {
    currentBank = bankSelect.value;
    statusEl.textContent = "Cargando datos‚Ä¶";
    loadMasterJson();
  });

  // Init
  populateBankSelect();
  loadMasterJson();
</script>

</body>
</html>
