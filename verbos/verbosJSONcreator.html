<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Constructor de JSON ‚Äì Verbos (bancos presente / pret√©rito)</title>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-slate-100 min-h-screen">
  <header class="bg-white shadow-sm">
    <div class="max-w-6xl mx-auto px-4 py-3 flex flex-col gap-2 sm:flex-row sm:items-center sm:justify-between">
      <div>
        <h1 class="text-lg sm:text-xl font-bold text-slate-800">
          Constructor de conjuntos ‚Äì Verbos (bancos)
        </h1>
        <p class="text-xs sm:text-sm text-slate-500">
          Carga <code>banco_presente.json</code> o <code>banco_preterito.json</code>, filtra por tags y
          selecciona hasta 20 conjugaciones (no todo el paradigma).
        </p>
      </div>
      <div class="flex flex-col items-end gap-1 text-right">
        <p id="status" class="text-xs text-slate-500">Cargando datos‚Ä¶</p>
        <p id="countInfo" class="text-xs text-slate-700 font-semibold">0 seleccionados (m√°x. 20)</p>
      </div>
    </div>
  </header>

  <main class="max-w-6xl mx-auto px-4 py-6 space-y-6">
    <!-- Source / bank selection -->
    <section class="bg-white rounded-2xl shadow p-4 space-y-3">
      <div class="flex flex-col gap-3 md:flex-row md:items-end md:justify-between">
        <div class="space-y-2">
          <label class="block text-xs font-semibold text-slate-600 uppercase tracking-wide">
            Banco de verbos
          </label>
          <select id="bankSelect"
                  class="border rounded-lg px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-sky-400">
            <option value="presente">Banco: Presente</option>
            <option value="preterito">Banco: Pret√©rito</option>
          </select>
          <p class="text-[11px] text-slate-500">
            Cambia de banco para construir conjuntos distintos. M√°s tarde podemos mezclar tiempos si quieres.
          </p>
        </div>

        <div class="flex-1 space-y-2">
          <label class="block text-xs font-semibold text-slate-600 uppercase tracking-wide">
            Buscar (infinitivo, sujeto o contexto)
          </label>
          <input id="searchInput"
                 type="text"
                 class="w-full border rounded-lg px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-sky-400"
                 placeholder="ej. hablar, yo, supermercado, quedarse‚Ä¶" />
        </div>

        <div class="flex flex-wrap gap-2 items-center">
          <button id="btnClear"
                  class="px-3 py-2 rounded-lg bg-slate-100 text-slate-700 text-xs font-semibold">
            Limpiar selecci√≥n
          </button>
          <button id="btnGenerate"
                  class="px-4 py-2 rounded-lg bg-emerald-600 text-white text-xs sm:text-sm font-semibold disabled:opacity-40 disabled:cursor-not-allowed"
                  disabled>
            Generar JSON (m√°x. 20)
          </button>
        </div>
      </div>

      <!-- Tag Filters -->
      <div class="border-t pt-3 mt-3">
        <label class="block text-xs font-semibold text-slate-600 uppercase tracking-wide mb-2">
          Filtrar por etiquetas (tags)
        </label>

        <div id="tagFilters" class="flex flex-wrap gap-2 text-xs">
          <!-- JS will dynamically populate all available tags -->
        </div>

        <p class="text-[11px] text-slate-500 mt-1">
          Los tags se leen tanto de <code>tags</code> como de <code>tipo_verbo</code> / <code>tipo_ver–±–æ</code>.
          Solo se muestran las conjugaciones cuyos tags (del verbo) incluyan todos los seleccionados.
        </p>
      </div>
    </section>

    <!-- List + Output -->
    <div class="grid gap-6 lg:grid-cols-[1.4fr,1fr]">
      <!-- List of items -->
      <section class="bg-white rounded-2xl shadow p-4 flex flex-col min-h-[300px]">
        <div class="flex items-center justify-between mb-3">
          <h2 class="text-sm font-semibold text-slate-700">
            √çtems disponibles
          </h2>
          <p id="listInfo" class="text-xs text-slate-500"></p>
        </div>

        <div id="itemsContainer"
             class="flex-1 min-h-[200px] max-h-[520px] overflow-auto space-y-2 text-sm">
          <!-- dynamically filled -->
        </div>
      </section>

      <!-- Output JSON -->
      <section class="bg-white rounded-2xl shadow p-4 space-y-3">
        <div class="flex items-center justify-between">
          <h2 class="text-sm font-semibold text-slate-700">
            Resultado JSON (para guardar como presente1.json, preterito1.json, etc.)
          </h2>
          <button id="btnCopy"
                  class="px-3 py-1.5 rounded-lg bg-sky-600 text-white text-xs font-semibold disabled:opacity-40 disabled:cursor-not-allowed"
                  disabled>
            Copiar al portapapeles
          </button>
        </div>

        <textarea id="outputJson"
                  class="w-full h-72 border rounded-lg px-3 py-2 text-xs font-mono bg-slate-50 focus:outline-none focus:ring-2 focus:ring-sky-400"
                  placeholder="Selecciona hasta 20 √≠tems y haz clic en ‚ÄúGenerar JSON‚Äù."
                  readonly></textarea>

        <p class="text-xs text-slate-500">
          Paso siguiente: crea un archivo como <code>presente1.json</code> (o similar) en tu repositorio
          y pega este contenido. Luego tu m√≥dulo de pr√°ctica solo necesita la URL de ese archivo.
        </p>
      </section>
    </div>
  </main>

  <script>
    // Bancos disponibles
    const VERB_BANKS = {
      presente: "https://raw.githubusercontent.com/scottscalici/imagenes/main/verbos/banco_presente.json",
      preterito: "https://raw.githubusercontent.com/scottscalici/imagenes/main/verbos/banco_preterito.json"
    };

    let currentBank = "presente";

    let masterItems = [];
    let filteredItems = [];
    const selectedIndices = new Set(); // indices relative to masterItems
    let allTags = new Set();
    let activeTags = new Set();

    const statusEl = document.getElementById("status");
    const countInfoEl = document.getElementById("countInfo");
    const listInfoEl = document.getElementById("listInfo");
    const itemsContainer = document.getElementById("itemsContainer");
    const searchInput = document.getElementById("searchInput");
    const bankSelect = document.getElementById("bankSelect");
    const btnGenerate = document.getElementById("btnGenerate");
    const btnClear = document.getElementById("btnClear");
    const btnCopy = document.getElementById("btnCopy");
    const outputJson = document.getElementById("outputJson");

    function updateCountInfo() {
      const count = selectedIndices.size;
      countInfoEl.textContent = `${count} seleccionados (m√°x. 20)`;
      btnGenerate.disabled = (count === 0 || count > 20);
      btnCopy.disabled = !outputJson.value.trim();
    }

    // Get tags from any entry, supporting multiple keys
    function getRawTagsFromEntry(v) {
      if (!v) return [];
      if (Array.isArray(v.tags)) return v.tags;
      if (Array.isArray(v["tipo_verbo"])) return v["tipo_verbo"];
      if (Array.isArray(v["tipo_ver–±–æ"])) return v["tipo_ver–±–æ"]; // por si acaso con la "o" rara
      return [];
    }

    function extractTagsFromYoEntries(items) {
      allTags = new Set();
      items.forEach(v => {
        if (v.sujeto?.trim().toLowerCase() === "yo") {
          const entryTags = getRawTagsFromEntry(v);
          entryTags.forEach(t => allTags.add(t));
        }
      });
    }

    function renderTagFilters() {
      const container = document.getElementById("tagFilters");
      container.innerHTML = "";
      activeTags = new Set(); // reset selection when cambiamos de banco

      if (!allTags.size) {
        container.innerHTML =
          '<span class="text-[11px] text-slate-400">Este banco no tiene tags detectables.</span>';
        return;
      }

      Array.from(allTags).sort().forEach(tag => {
        const id = `tag-${tag}`;
        const wrapper = document.createElement("label");
        wrapper.className =
          "flex items-center gap-1 bg-slate-100 px-2 py-1 rounded cursor-pointer";

        wrapper.innerHTML = `
          <input type="checkbox" id="${id}" data-tag="${tag}" class="h-3 w-3">
          <span>${tag}</span>
        `;

        container.appendChild(wrapper);
      });

      container.querySelectorAll("input[type='checkbox']").forEach(cb => {
        cb.addEventListener("change", () => {
          const tag = cb.dataset.tag;
          if (cb.checked) activeTags.add(tag);
          else activeTags.delete(tag);
          applyFilter();
        });
      });
    }

    function renderList() {
      itemsContainer.innerHTML = "";

      if (!filteredItems.length) {
        itemsContainer.innerHTML =
          '<p class="text-xs text-slate-500">No hay √≠tems que coincidan con la b√∫squeda/filtros.</p>';
        listInfoEl.textContent = "";
        return;
      }

      filteredItems.forEach(({ item, indexInMaster }) => {
        const isSelected = selectedIndices.has(indexInMaster);

        const row = document.createElement("label");
        row.className =
          "flex items-start gap-2 border rounded-lg px-3 py-2 cursor-pointer hover:bg-slate-50 text-xs sm:text-sm";

        row.innerHTML = `
          <input type="checkbox"
                 class="mt-1 h-4 w-4 text-sky-600 border-slate-300 rounded"
                 data-master-index="${indexInMaster}"
                 ${isSelected ? "checked" : ""} />
          <div class="flex-1">
            <div class="flex flex-wrap items-center gap-1">
              <span class="font-semibold text-slate-800">${item.sujeto}</span>
              <span class="text-slate-800">${item.contexto || ""}</span>
            </div>
            <div class="text-[11px] text-slate-500 mt-0.5">
              ${item.infinitivo} ¬∑ forma correcta: <code>${item.forma}</code>
              ¬∑ traducci√≥n: ${item.traducci√≥n || ""} ¬∑ tiempo: ${item.tiempo || ""}
            </div>
          </div>
        `;

        itemsContainer.appendChild(row);
      });

      listInfoEl.textContent = `${filteredItems.length} √≠tems visibles`;
      updateCountInfo();

      itemsContainer.querySelectorAll('input[type="checkbox"]').forEach(cb => {
        cb.addEventListener("change", () => {
          const idx = Number(cb.dataset.masterIndex);
          if (cb.checked) {
            if (selectedIndices.size >= 20) {
              cb.checked = false;
              return;
            }
            selectedIndices.add(idx);
          } else {
            selectedIndices.delete(idx);
          }
          updateCountInfo();
        });
      });
    }

    function applyFilter() {
      const q = searchInput.value.trim().toLowerCase();

      filteredItems = masterItems
        .map((item, indexInMaster) => ({ item, indexInMaster }))
        .filter(({ item }) => {
          const haystack = (
            (item.infinitivo || "") + " " +
            (item.sujeto || "") + " " +
            (item.contexto || "")
          ).toLowerCase();

          // TEXT FILTER
          const passText = !q || haystack.includes(q);

          // TAG FILTER (basado en los tags del verbo, tomados del YO)
          let passTags = true;
          if (activeTags.size) {
            const subjLower = (item.sujeto || "").trim().toLowerCase();
            let tags = [];

            if (subjLower === "yo") {
              tags = getRawTagsFromEntry(item);
            } else {
              const yo = masterItems.find(
                x =>
                  x.infinitivo === item.infinitivo &&
                  (x.tiempo === item.tiempo || !x.tiempo || !item.tiempo) &&
                  (x.sujeto || "").trim().toLowerCase() === "yo"
              );
              tags = getRawTagsFromEntry(yo);
            }

            if (!tags.length) {
              passTags = false;
            } else {
              // exige que est√©n todos los tags activos presentes
              passTags = Array.from(activeTags).every(t => tags.includes(t));
            }
          }

          return passText && passTags;
        });

      renderList();
    }

async function loadMasterJson() {
  try {
    const url = VERB_BANKS[currentBank];
    const res = await fetch(url);
    let data = await res.json();

    // üîç 1) If it's an object like { algo: [ ... ], otro: [ ... ] }
    if (!Array.isArray(data) && typeof data === "object" && data !== null) {
      const arrays = Object.values(data).filter(Array.isArray);
      if (arrays.length) {
        data = arrays.flat();
      }
    }

    // üîç 2) If it's an array-of-arrays, flatten one level (or more)
    if (Array.isArray(data)) {
      // flatten arbitrarily nested arrays into one big list
      const flatten = (arr) =>
        arr.reduce(
          (acc, el) =>
            Array.isArray(el) ? acc.concat(flatten(el)) : acc.concat(el),
          []
        );
      data = flatten(data);
    } else {
      data = [];
    }

    // ‚úÖ At this point, data should be the flat list of all conjugation objects
    masterItems = data;

    extractTagsFromYoEntries(masterItems);
    renderTagFilters();

    selectedIndices.clear();
    outputJson.value = "";
    btnCopy.disabled = true;
    updateCountInfo();

    statusEl.textContent =
      `Cargados ${masterItems.length} √≠tems del banco ${currentBank}.`;
    applyFilter();
  } catch (err) {
    console.error(err);
    statusEl.textContent =
      "Error al cargar el JSON del banco. Revisa la URL.";
    itemsContainer.innerHTML =
      '<p class="text-xs text-red-500">No se pudo cargar el archivo JSON.</p>';
  }
}


    // Generate JSON for selected items
    btnGenerate.addEventListener("click", () => {
      if (!selectedIndices.size || selectedIndices.size > 20) return;

      const indicesSorted = Array.from(selectedIndices).sort((a, b) => a - b);
      const selectedItems = indicesSorted.map(i => masterItems[i]);

      const jsonString = JSON.stringify(selectedItems, null, 2);
      outputJson.value = jsonString;
      btnCopy.disabled = false;
    });

    // Clear selection
    btnClear.addEventListener("click", () => {
      selectedIndices.clear();
      updateCountInfo();
      renderList();
      outputJson.value = "";
      btnCopy.disabled = true;
    });

    // Filter on typing
    searchInput.addEventListener("input", () => {
      applyFilter();
    });

    // Switch bank
    bankSelect.addEventListener("change", () => {
      currentBank = bankSelect.value;
      statusEl.textContent = "Cargando datos‚Ä¶";
      loadMasterJson();
    });

    // Copy to clipboard
    btnCopy.addEventListener("click", async () => {
      const text = outputJson.value;
      if (!text.trim()) return;
      try {
        await navigator.clipboard.writeText(text);
        btnCopy.textContent = "¬°Copiado!";
        setTimeout(() => (btnCopy.textContent = "Copiar al portapapeles"), 1500);
      } catch {
        btnCopy.textContent = "Error al copiar";
        setTimeout(() => (btnCopy.textContent = "Copiar al portapapeles"), 1500);
      }
    });

    // Init
    loadMasterJson();
  </script>
</body>
</html>
